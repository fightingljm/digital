<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>构造函数</title>
</head>
<body>
	<script>
//构造函数
//值类型(布尔值,null,undefined),直接存到地址里==一样的地址   引用类型(对象  函数  数组)==不一样的地址
		function Creat(name,age){
			this.name=name;//this指向用new和构造函数创建的对象   添加实例属性
			this.age=age;
			this.say=function(){
				console.log("我叫"+this.name+"今年"+this.age+"岁")
				//return "我叫"+this.name+"今年"+this.age+"岁"
			}
		}
		var obj1=new Creat("liu",18)//new关键字+构造函数  可以创建实例化对象
		var obj2=new Creat("liu",18)
		obj1.say();
		obj2.say();
		console.log(obj1.say())//undefined,因为没有返回值
		console.log(obj2.say())
		console.log(obj1.say)
		console.log(obj2.say)
		console.log(obj1.say()==obj2.say())//true,undefined==undefined
		console.log(obj1.say==obj2.say)//false()

		//原型  创建一个对象会产生一个原型
		function Person(){}
		Person.prototype.user="liu"//prototype构造函数的属性,指向原型对象;添加共享原型属性
		Person.prototype.age=20
		var p1=new Person()
		var p2=new Person()
		console.log(p1.user)
		console.log(p2.user)
		p1.user="jin"
		console.log(p1.user)
		console.log(p2.user)

		console.log(Person.prototype.constructor)//constructor原型对象的属性,指向构造函数本身
		console.log(p1.__proto__)//__proto__构造函数创建的对象的属性,指向原型对象
		console.log(p2.__proto__)
		console.log(p1.__proto__==p2.__proto__)//true,构造函数的原型对象只有一个

		//prototype添加共享原型属性,方法一
		/*function Person(name,age){
			this.name=name;//this指向用new和构造函数创建的对象   添加实例属性
			this.age=age;
		}
		Person.prototype.say=function(){//添加共享原型属性
			console.log("我叫"+this.name+"今年"+this.age+"岁")
		}
		var p1=new Person("liu",20)
		var p2=new Person("jin",20)
		p1.say();
		p2.say();*/
		//prototype添加共享原型属性,方法二
		/*function Person(name,age){
			this.name=name;//this指向用new和构造函数创建的对象   添加实例属性
			this.age=age;
		}
		Person.prototype={//添加共享原型属性
			sayName:function(){
				console.log(this.name)
			},
			sayAge:function(){
				console.log(this.age)
			}
		}
		var p1=new Person("liu",20)
		var p2=new Person("jin",20)
		p1.sayName();
		p1.sayAge();
		p2.sayName();
		p2.sayAge();
		console.log(Person.prototype.constructor)//function Object() { [native code] };constructor属性失效*/


		/*Array.prototype.name="liu"
		var arr=[1,2,3]
		console.log(arr.name)*/

		/*//继承--原型链
		function Person(name){
			this.name=name;
		}
		Person.prototype.sayName=function(){//添加共享原型属性
			console.log(this.name)
		}
		function Person1(age){
			this.age=age;
		}
		Person1.prototype=new Person("jin")//继承
		Person1.prototype.sayAge=function(){//添加共享原型属性
			console.log(this.age)
		}
		Person1.prototype.constructor=Person1
		var p1=new Person("liu")
		var p2=new Person1(20)
		p1.sayName();

		p2.sayName();
		p2.sayAge();
		console.log(Person1.prototype.constructor)*/
	</script>
</body>
</html>